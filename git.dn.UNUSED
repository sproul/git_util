#!/bin/bash -x

. git.sync

dry_mode=''
force_mode=''
refresh_mode=''
t=`mktemp`; trap "rm $t" EXIT
verbose_mode=''
while [ -n "$1" ]; do
        case "$1" in
                -dry)
                        dry_mode=-dry
                ;;
                -f|-force)
                        force_mode=-force
                ;;
                -q|-quiet)
                        verbose_mode=''
                ;;
                r|-refresh)
                        refresh_mode=-refresh
                ;;
                -v|-verbose)
                        verbose_mode=-v
                ;;
                *)
                        break
                ;;
        esac
        shift
done
dir="${1-`pwd`}"
if [ ! -d "$dir" ]; then
        echo "$0: error: could not find file \"$dir\"" 1>&2
        exit 1
fi
if [ -d "$dir/.git" ]; then
        if [ -n "$refresh_mode" ]; then
                echo.clean "rm -rf $TMP/.git"
                echo.clean "mv \"$dir/.git\" $TMP"
                if [ -z "$dry_mode" ]; then
                        rm -rf $TMP/.git
                        if ! mv "$dir/.git" $TMP; then
                                echo "$0: mv $dir/.git $TMP failed, exiting..." 1>&2
                                exit 1
                        fi
                fi
        else
                echo.clean "cd       \"$dir\""
                if [ -z "$dry_mode" ]; then
                        cd       "$dir"
                fi
                echo "git stash list"
                stashes_already_in_place=`git stash list`
                if [ -n "$stashes_already_in_place" ]; then
                        echo "$0: error: did not expect to see stashes already in place. Resolve them before continuing (or run w/ -force)" 1>&2
                        git stash show -p
                        exit 1
                fi
                
                echo "git stash save"
                #
                # This can lead to git merge errors. Use this command on a per file basis in order to reset the merge record-keeping, 
                # as here for, e.g., git.up:
                # 
                #   git reset --merge git.up
                #   
                if !  git stash save > $t; then
                        echo "$0: git stash save failed, exiting..." 1>&2
                        exit 1
                fi
                if [ "`head -1 $t`" = "No local changes to save" ]; then
                        stashed=''
                else
                        stashed='yes'
                fi
                echo "git pull origin master"
                if [ -z "$dry_mode" ]; then
                        if ! git pull origin master; then
                                echo "$0: git pull origin master failed, exiting..." 1>&2
                                exit 1
                        fi
                fi
                if [ -n "$stashed" ]; then
                        echo "git stash pop"
                        if !  git stash pop; then
                                echo "$0: git stash pop failed, exiting..." 1>&2
                                exit 1
                        fi
                fi
                exit
        fi
fi
ng="/tmp/$name.git.dn"
rm -rf "$ng"
if ! mkdir "$ng"; then
        echo "$0: mkdir $ng failed, exiting..." 1>&2
        exit 1
fi
cd "$ng"
if [ -n "$force_mode" ]; then
        echo "since we are in force mode, removing added files"
        echo "git clean  -d  -f ."
        git       clean  -d  -f .
fi
name=`basename "$dir"`
#remote_repo=`git.get_remote_repo git@github.com:sproul/$name.git`
remote_repo=https://$ghpat2@github.com/sproul/$name.git
echo "git clone $remote_repo"
if [ -z "$dry_mode" ]; then
        if ! git clone $remote_repo 2> $ng/out; then
                echo "$0: git clone $remote_repo failed, exiting..." 1>&2
                exit 1
        fi
fi 
echo.clean "mv $ng/$name/.git \"$dir\""
if [ -z "$dry_mode" ]; then
        mv $ng/$name/.git "$dir"
fi
if ! grep 'warning: You appear to have cloned an empty repository.' $ng/out > /dev/null 2>&1; then
        echo.clean "difr \"$dir\" \"$ng/$name\""
        if [ -z "$dry_mode" ]; then
                difr "$dir" "$ng/$name"
        fi
fi

exit
dir=$dp/bin
exit
bx $dp/bin/git.dn r $dp/bin
bx $dp/bin/git.dn $dp/emacs