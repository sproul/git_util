#!/bin/bash
. git_util.inc
. git.prep_auth.inc
t=`mktemp`; trap "rm -f $t*; Restore_clean_configs" EXIT
branch=`git.branch`
new_file_list=''

Possibly_propagate_update()
{
        repo_name=$1
        git_status_output_fn=$2
        target_dir=''
        case $repo_name in
                monr)
                        case "$HOSTNAME" in
                                VMS3|TRADES)
                                        target_dir=$HOME/git/monroe.biz
                                ;;
                        esac
                ;;
                fin_doc_parser)
                        case "$HOSTNAME" in
                                qascraper)
                                        target_dir=$HOME/git/qwickanalyticsscraper
                                ;;
                        esac                        
                ;;
        esac
        if [ -z $target_dir ]; then
                return 0
        fi
        if [ ! -d $target_dir ]; then
                echo "WARNING expected to see $target_dir for a propagated checkin" 1>&2
                return 1
        fi
        for updated_fn in `grep '^ [AM] ' $git_status_output_fn | sed -e 's/^ [AM] //'`; do
                dest_fn=$target_dir/$updated_fn
                mkdir -p `dirname $dest_fn`
                echo.clean "cp $updated_fn $dest_fn"
                cp             $updated_fn $dest_fn
        done
        (
        echo.clean "cd $target_dir"
        cd             $target_dir
        echo.clean "git.up"
        git.up
        )
}

Git_status()
{
        if [ ! -f $t.status ]; then
                git status --short > $t.status
        fi
        cat $t.status
}

Push()
{
        Prep_auth
        if git push origin $branch > $t 2>&1; then
                return 0
        fi
        if ! grep 'merge the remote changes' $t > /dev/null 2>&1; then
                if ! grep 'integrate the remote changes' $t > /dev/null 2>&1; then
                        cat $t
                        return 1
                fi
        fi
        echo $0 saw merge problem...
        echo ===========================================================================
        cat $t
        echo ===========================================================================
        echo will try to rectify by rebasing, which will auto-merge if practical:
        # before pushing, do this, will auto-merge:
        echo "git pull --rebase"
        if [ -z "$dry_mode" ]; then
                if ! git pull --rebase; then
                        echo "$0: git pull --rebase failed......................" 1>&2
                        echo "git status"
                        Git_status
                        echo EOD
                        echo a way to resolve this:
                        echo git.repair
                        return 1
                fi
        fi
        if ! git push origin $branch; then
                echo "$0: error: git push origin failed" 1>&2
                return 1
        else
                . modified_repos.inc
                git_util__modified_repos__Remove_from_list $repo_name
                rm -f $t.status
        fi
}

Modified()
{
        fn="$1"
        if Git_status | grep " M $fn$" > /dev/null 2>&1; then
                return 0
        else
                return 1
        fi
}

Change_set_consists_entirely_of_new_files()
{
        git status > $t
        if grep modified: $t > /dev/null 2>&1; then
                return 1
        fi
        if ! grep 'untracked files' $t > /dev/null 2>&1; then
                return 1
        fi
        new_file_list=`grep '^#*	' $t | sed -e 's/#	//' | tr '\n' ' '`
}

Change_set_consists_entirely_of_deletions()
{
        git status > $t
        if grep modified: $t > /dev/null 2>&1; then
                return 1
        fi
        if grep 'untracked files' $t > /dev/null 2>&1; then
                return 1
        fi
        if grep 'deleted:' $t > /dev/null 2>&1; then
                return 0
        fi
}

Checkin()
{
        z=`pwd`
        if [ -f git.pre_checkin_test.sh ]; then
                if ! bash git.pre_checkin_test.sh $force_mode; then
                        if [ -n "$force_mode" ]; then
                                echo "$0: bash git.pre_checkin_test.sh failed, forcing anyway..." 1>&2
                        else
                                echo "$0: bash git.pre_checkin_test.sh failed, exiting..." 1>&2
                                return 1
                        fi
                fi
        fi
        current_dir=`basename "$z"`
        repo_name=$current_dir
        echo gu $repo_name in $z...
        git.changed_or_added_files.ls > $t.changed_or_added
        patt="EARLY"
        patt="$patt.*exit"
        if grep -n "$patt" $t.changed_or_added; then
                echo FAILED early exit indicates debugging
        else
                echo OK no early exit
        fi
        grep '\.sh$'  $t.changed_or_added >  $t.changed_or_added_sh
        grep '\.inc$' $t.changed_or_added >> $t.changed_or_added_sh
        if [ -s $t.changed_or_added_sh ]; then
                if grep -n "^  *EOF$" $t.changed_or_added_sh; then
                        echo FAILED suspiciously indented EOF, possible malformed here-doc
                        if [ -n "$force_mode" ]; then
                                if [ -n "$verbose_mode" ]; then
                                        echo OK force mode says we push on no matter what
                                fi
                        else
                                return 1
                        fi
                else
                        echo OK no suspicious here-doc
                fi
        fi
        if Commit_routine_changes; then
                changes_seen=yes
        fi
        if [ -z "$comment" ]; then
                if Change_set_consists_entirely_of_new_files; then
                        comment="add $new_file_list"
                elif Change_set_consists_entirely_of_deletions; then
                        comment="add superfluous file(s)"
                else
                        case "$repo_name" in
                                data)
                                        comment="shell records"
                                ;;
                                emacs)
                                        comment="shortcut update"
                                ;;
                                home)
                                        comment="IP updates"
                                ;;
                        esac
                fi
        fi        
        case "$repo_name" in
                fin_doc_parser)
                        # frequently aborted test case leads to these files being deleted, and a cascade of false updates. Restore them before update:
                        cp ui/src/public/MCBI_Q2_2018_Report.textract0.json.bak ui/src/public/MCBI_Q2_2018_Report.textract0.json
                        cp ui/src/public/MCBI_Q2_2018_Report.textract.csv.bak ui/src/public/MCBI_Q2_2018_Report.textract.csv
                ;;
        esac
        branch=`git.branch`
        Prep_auth
        if git.ac $dry_mode $comment; then
                echo "git push origin $branch"
                if [ -z "$dry_mode" ]; then
                        Git_status
                        Possibly_propagate_update $repo_name $t.status
                        # If someone has beaten us to the punch in getting an update in since our pull, we'll get the following:
                        #       error: failed to push some refs to 'https://sproul:...@github.com/sproul/t2.git'
                        #       hint: Updates were rejected because the remote contains work that you do
                        #       hint: not have locally. This is usually caused by another repository pushing
                        #       hint: to the same ref. You may want to first merge the remote changes (e.g.,
                        #       hint: 'git pull') before pushing again.
                        #       hint: See the 'Note about fast-forwards' in 'git push --help' for details.
                        if Push; then
                                echo "git pull origin $branch"
                                if ! git pull origin $branch; then
                                        echo "$0: git pull failed, returning..." 1>&2
                                        return 1
                                fi
                        fi
                fi
        fi
        echo "git pull origin $branch"
        if ! git pull origin $branch; then
                echo "$0: git pull failed, returning..." 1>&2
                return 1
        fi
        . modified_repos.inc
        git_util__modified_repos__Remove_from_list $repo_name
        if [ -f git.post_checkin.sh ]; then
                echo "bash -x git.post_checkin.sh $comment"
                bash       -x git.post_checkin.sh $comment
        fi
}

Commit()
{
        comment="$1"
        shift
        
        echo.clean "git add $*"
        git             add $*
        echo.clean "git commit -m  $comment"
        git             commit -m "$comment"
}

Commit_routine_changes()
{
        proj=`pwd | sed -e 's;.*/;;'`
        Git_status
        case $proj in
                bin)
                        if grep Linux/carson.can $t.status > $t.carson.cans 2>&1; then
                                fns=`cat $t.carson.cans | sed -e 's/.*Linux/Linux/'`
                                Commit 'clojure notes' $fns
                                changes_seen=yes
                        fi
                        if Modified g.sh; then
                                Commit 'adjusted project search settings' g.sh
                                changes_seen=yes
                        fi
                        if [ -z "$changes_seen" ]; then
                                return
                        fi
                ;;
                emacs)
                        if grep lisp/data/n-data-menu-browse $t.status > /dev/null 2>&1; then
                                fns=`cat $t.carson.cans | sed -e 's/.*lisp/lisp/'`
                                Commit 'shortcut updates' $fns
                        else
                                return
                        fi
                ;;
                *)
                        return
                ;;
        esac
        Push || return 1
}

Changes_seen()
{
        if Git_status | grep '^ [DMA] ' > /dev/null 2>&1; then
                return 0
        else
                return 1
        fi
}

Pull_latest_updates_if_no_local_changes()
{
        proj=${1-$(basename $(pwd))}
        d=${2-$dp}
        if [ ! -d $d/$proj ]; then
                return
        fi
        cd $d/$proj
        changes_to_be_pushed=''
        Commit_routine_changes $proj $d || return 1
        if Changes_seen; then
                return
        fi
        rm $t.status
        Prep_auth
        echo "git pull origin $branch"
        git       pull origin $branch
}

Synchronize_high_traffic_shared_projects()
{
        for proj in bin data emacs git_util; do
                echo $proj==========================================================
                Pull_latest_updates_if_no_local_changes $proj
        done
        case "$HOSTNAME" in
                lt5|x-mac)
                        Pull_latest_updates_if_no_local_changes doc             $dx
                        Pull_latest_updates_if_no_local_changes fin_doc_parser  $dx
                        Pull_latest_updates_if_no_local_changes monr
                        if orcl.on_vpn; then
                                Pull_latest_updates_if_no_local_changes diagnostic-tool
                        fi
                ;;
        esac

}


Find_comment_in_source_tree()
{
        dotc_list=`find . -name '.c'`
        if [ -n "$dotc_list" ]; then
                comment=`cat $dotc_list`
                rm $dotc_list
                echo $comment
        fi
}

Resolve_comment()
{
        comment_from_parms="$*"
        comment_from_c=`Find_comment_in_source_tree`
        if [ -n "$comment_from_c" ]; then
                if [ -n "$comment_from_parms" ]; then
                        echo "$0: error: did not expect $comment_from_c and also a command line comment -- which should I use?" 1>&2
                        return 1
                fi
                comment="$comment_from_c"
        else
                comment="$comment_from_parms"
        fi
        echo $comment
}

Test_init()
{
        test_dir1=$dp/git/java_scratch
        test_dir2=$HOME/git/java_scratch
        if [ -n "$test_env_wipe_first" ]; then
                echo "rm -rf $test_dir1 $test_dir2"
                rm       -rf $test_dir1 $test_dir2
        fi
        tf=papa_testing_area/whatever.$$
        
        if [ ! -d $test_dir2 ]; then
                git.clone java_scratch
                if [ ! -d $test_dir2 ]; then
                        echo "FAIL apparently git.clone $test_dir2 did not work" 1>&2
                        exit 1
                fi
                mkdir -p $test_dir2/`dirname $tf`
        fi
        echo "OK $test_dir2"
        if [ ! -d $test_dir1 ]; then
                cp       -pr $test_dir2 $test_dir1
                if [ ! -d $test_dir1 ]; then
                        echo "FAIL cp to \"$test_dir1\"" 1>&2
                        exit 1
                fi
        fi
        echo "OK $test_dir1"
}


Test_simple_chi()
{
        cd $test_dir1
        branch=`git.branch`
        
        echo hi > $tf
        git.up > $t.git.up1 2>&1
        
        cd $test_dir2
        branch=`git.branch`
        
        assert.f.exist -not "test ck $tf not there early" $tf $tf
        git.up no changes here, but expecting to sync in $tf from $test_dir1
        assert.f.exist -label "after git.up in $test_dir2, should see change from $test_dir1" $tf
        git rm $tf
        git.up "removed $tf for test"
        cd $test_dir1
        git.up "no changes, but syncing should rm $tf"
        assert.f.exist -not "$tf removed in $test_dir2, so should also be removed in $test_dir1" $tf
}

Test_2_simultaneous_chis()
{
        echo Test_2_simultaneous_chis
}

Test_Pull_latest_updates_if_no_local_changes()
{
        echo Test_Pull_latest_updates_if_no_local_changes
}

Test()
{
        Test_init
        Test_simple_chi
        Test_2_simultaneous_chis
        Test_Pull_latest_updates_if_no_local_changes
}

export PATH=$PATH:`dirname $0`
. git.sync

t=`mktemp`
repo_name=''
dry_mode=''
force_mode=''
new_branch=''
verbose_mode=''
while [ -n "$1" ]; do
        case "$1" in
                a|-all)
                        git.all $dry_mode git.up
                        exit
                ;;
                -in_dir)
                        shift
                        cd "$1"
                ;;
                -dry|-dry_run)
                        dry_mode=-dry
                ;;
                -f|-force)
                        force_mode=-force
                ;;
                -new_branch)
                        new_branch_flag="$1"
                        shift
                        new_branch="$1"
                ;;
                -Pull_latest_updates_if_no_local_changes)
                        shift
                        Pull_latest_updates_if_no_local_changes       $*
                        exit
                ;;
                -repo)
                        shift
                        repo_name=$1
                        # if we use this option, we can run from any directory, and the appropriate repo dir will be found (and we will cd there)
                        found=''
                        if [ -d $HOME/git/$repo_name ]; then
                                echo "cd $HOME/git/$repo_name"
                                cd       $HOME/git/$repo_name
                                found=yes
                        else
                                for f in `ls -d $dp/*/$repo_name $dx/*/$repo_name 2> /dev/null`; do
                                        if [ -d "$f" ]; then
                                                echo "cd $f"
                                                cd       $f
                                                found=yes
                                                break
                                        fi
                                done
                        fi
                        if [ -z "$found" ]; then
                                echo "$0: error: could not find repo named $repo_name" 1>&2
                                exit 1
                        fi
                ;;
                -Synchronize_high_traffic_shared_projects_if_no_local_changes)
                        Synchronize_high_traffic_shared_projects
                        exit
                ;;
                -test)
                        Test
                ;;
                -test0)
                        test_env_wipe_first=yes
                        Test
                ;;
                -v|-verbose)
                        verbose_mode=-verbose
                ;;
                *)
                        break
                ;;
        esac
        shift
done

comment=`Resolve_comment $*` || echo 1
Checkin || exit 1

exit
bx $dp/bin/git.up -dry_run
ssh -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=0  $ip dp/git_util/git.up -in_dir dp/git/fin_doc_parser
ssh -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=0 $aip git.up -in_dir dp/git/fin_doc_parser
bx $dp/git_util/git.up -Synchronize_high_traffic_shared_projects_if_no_local_changes
bx $dp/git_util/git.up -Pull_latest_updates_if_no_local_changes
exit 0
