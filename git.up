#!/bin/bash
. git_util.inc
. git.prep_auth.inc
t=`mktemp`; trap "rm $t" EXIT

Possibly_propagate_update()
{
        repo_name=$1
        git_status_output_fn=$2
        target_dir=''
        case $repo_name in
                monr)
                        case "$HOSTNAME" in
                                VMS3|TRADES)
                                        target_dir=$HOME/git/monroe.biz
                                ;;
                        esac
                ;;
                fin_doc_parser)
                        case "$HOSTNAME" in
                                qascraper)
                                        target_dir=$HOME/git/qwickanalyticsscraper
                                ;;
                        esac                        
                ;;
        esac
        if [ -z $target_dir ]; then
                return 0
        fi
        if [ ! -d $target_dir ]; then
                echo "WARNING expected to see $target_dir for a propagated checkin" 1>&2
                return 1
        fi
        for updated_fn in `grep '^ [AM] ' $git_status_output_fn | sed -e 's/^ [AM] //'`; do
                dest_fn=$target_dir/$updated_fn
                mkdir -p `dirname $dest_fn`
                echo.clean "cp $updated_fn $dest_fn"
                cp             $updated_fn $dest_fn
        done
        (
        echo.clean "cd $target_dir"
        cd             $target_dir
        echo.clean "git.up"
        git.up
        )
}

Checkin()
{
        z=`pwd`
        if [ -f git.pre_checkin_test.sh ]; then
                if ! bash git.pre_checkin_test.sh $force_mode; then
                        if [ -n "$force_mode" ]; then
                                echo "$0: bash git.pre_checkin_test.sh failed, forcing anyway..." 1>&2
                        else
                                echo "$0: bash git.pre_checkin_test.sh failed, exiting..." 1>&2
                                return 1
                        fi
                fi
        fi
        current_dir=`basename "$z"`
        repo_name=$current_dir
        echo gu $repo_name in $z...
        patt="EARLY"
        patt="$patt.*exit"
        case $repo_name in
                bin|data|home|monr|pcaapps)
                        # skip search, which will be triggered by noise in shell buffers, or is N/A for whatever reason
                ;;
                *)
                        # skip this test if we are dealing with an old version of g.sh
                        if grep -l ' -project_exists' $dp/bin/g.sh > /dev/null 2>&1; then
                                if g.sh -project_exists $repo_name; then
                                        g.sh -search $repo_name "$patt" > $t
                                        if [ -s "$t" ]; then
                                                ls -l $t
                                                echo FAILED early exit indicates debugging
                                                if [ -n "$force_mode" ]; then
                                                        if [ -n "$verbose_mode" ]; then
                                                                echo OK force mode says we push on no matter what
                                                        fi
                                                else
                                                        return 1
                                                fi
                                        fi
                                fi
                        fi
                ;; 
        esac
        if [ -n "$verbose_mode" ]; then
                echo OK no early exit
        fi
        if [ -z "$comment" ]; then
                case "$repo_name" in
                        emacs)
                                comment="shortcut update"
                        ;;
                esac
        fi
        case "$repo_name" in
                fin_doc_parser)
                        # frequently aborted test case leads to these files being deleted, and a cascade of false updates. Restore them before update:
                        cp ui/src/public/MCBI_Q2_2018_Report.textract0.json.bak ui/src/public/MCBI_Q2_2018_Report.textract0.json
                        cp ui/src/public/MCBI_Q2_2018_Report.textract.csv.bak ui/src/public/MCBI_Q2_2018_Report.textract.csv
                ;;
        esac
        branch=`git.branch`
        Prep_auth
        if git.ac $dry_mode $comment; then
                echo "git push origin $branch"
                if [ -z "$dry_mode" ]; then
                        git status --short  > $t.status
                        Possibly_propagate_update $repo_name $t.status
                        # If someone has beaten us to the punch in getting an update in since our pull, we'll get the following:
                        #       error: failed to push some refs to 'https://sproul:...@github.com/sproul/t2.git'
                        #       hint: Updates were rejected because the remote contains work that you do
                        #       hint: not have locally. This is usually caused by another repository pushing
                        #       hint: to the same ref. You may want to first merge the remote changes (e.g.,
                        #       hint: 'git pull') before pushing again.
                        #       hint: See the 'Note about fast-forwards' in 'git push --help' for details.
                        if git push origin $branch > $t 2>&1; then
                                git pull origin $branch
                        else
                                if ! grep 'merge the remote changes' $t > /dev/null 2>&1; then
                                        if ! grep 'integrate the remote changes' $t > /dev/null 2>&1; then
                                                cat $t
                                                return 1
                                        fi
                                fi
                                echo $0 saw merge problem...
                                echo ===========================================================================
                                cat $t
                                echo ===========================================================================
                                echo will try to rectify by rebasing, which will auto-merge if practical:
                                # before pushing, do this, will auto-merge:
                                echo "git pull --rebase"
                                if [ -z "$dry_mode" ]; then
                                        if ! git pull --rebase; then
                                                echo "$0: git pull --rebase failed......................" 1>&2
                                                echo "git status"
                                                git status
                                                echo EOD
                                                echo a way to resolve this:
                                                echo git.repair
                                                return 1
                                        fi
                                fi
                                if ! git push origin $branch; then
                                        echo "$0: error: git push origin failed" 1>&2
                                        return 1
                                fi
                        fi
                fi
        fi
        echo "git pull origin $branch"
        if ! git pull origin $branch; then
                echo "$0: git pull failed, returning..." 1>&2
                return 1
        fi
        . modified_repos.inc
        git_util__modified_repos__Remove_from_list $repo_name
}

Commit_routine_changes()
{
        proj=`pwd | sed -e 's;.*/;;'`
        git status --short > $t.status
        case $proj in
                bin)
                        if grep Linux/carson.can $t.status > $t.carson.cans 2>&1; then
                                fns=`cat $t.carson.cans | sed -e 's/.*Linux/Linux/'`
                                echo.clean "git add $fns"
                                git             add $fns
                                echo.clean "git commit -m 'clojure notes'"
                                git             commit -m 'clojure notes' $fns
                                return 0
                        fi
                ;;
                emacs)
                        if grep lisp/data/n-data-menu-browse $t.status > /dev/null 2>&1; then
                                fns=`cat $t.carson.cans | sed -e 's/.*lisp/lisp/'`
                                echo.clean "git commit -m 'shortcut updates' $fns"
                                git             commit -m 'shortcut updates' $fns
                                return 0
                        fi
                ;;
        esac
        return 1
}

Pull_latest_updates_if_no_local_changes()
{
        proj=${1-$(basename $(pwd))}
        d=${2-$dp}
        if [ ! -d $d/$proj ]; then
                return
        fi
        cd $d/$proj
        changes_to_be_pushed=''
        if Commit_routine_changes $proj $d; then
                changes_to_be_pushed=yes
        fi
        if Changes_seen_in_git_status_output $t.status; then
                if [ -z "$changes_to_be_pushed" ]; then
                        echo changes seen that are not routine, so leaving it alone
                        return
                fi
        fi
        rm $t.status
        branch=`git.branch`
        Prep_auth
        echo "git pull origin $branch"
        git       pull origin $branch
}

Synchronize_high_traffic_shared_projects()
{
        for proj in bin data emacs git_util; do
                echo $proj==========================================================
                Pull_latest_updates_if_no_local_changes $proj
        done
        case "$HOSTNAME" in
                lt5|x-mac)
                        Pull_latest_updates_if_no_local_changes doc             $dx
                        Pull_latest_updates_if_no_local_changes fin_doc_parser  $dx
                        Pull_latest_updates_if_no_local_changes monr
                        if orcl.on_vpn; then
                                Pull_latest_updates_if_no_local_changes diagnostic-tool
                        fi
                ;;
        esac

}


Find_comment_in_source_tree()
{
        dotc_list=`find . -name '.c'`
        if [ -n "$dotc_list" ]; then
                comment=`cat $dotc_list`
                rm $dotc_list
                echo $comment
        fi
}

Resolve_comment()
{
        comment_from_parms="$*"
        comment_from_c=`Find_comment_in_source_tree`
        if [ -n "$comment_from_c" ]; then
                if [ -n "$comment_from_parms" ]; then
                        echo "$0: error: did not expect $comment_from_c and also a command line comment -- which should I use?" 1>&2
                        return 1
                fi
                comment="$comment_from_c"
        else
                comment="$comment_from_parms"
        fi
        echo $comment
}

export PATH=$PATH:`dirname $0`
. git.sync

t=`mktemp`
repo_name=''
dry_mode=''
force_mode=''
new_branch=''
verbose_mode=''
while [ -n "$1" ]; do
        case "$1" in
                a|-all)
                        git.all $dry_mode git.up
                        exit
                ;;
                -in_dir)
                        shift
                        cd "$1"
                ;;
                -dry|-dry_run)
                        dry_mode=-dry
                ;;
                -f|-force)
                        force_mode=-force
                ;;
                -new_branch)
                        new_branch_flag="$1"
                        shift
                        new_branch="$1"
                ;;
                -Pull_latest_updates_if_no_local_changes)
                        shift
                        Pull_latest_updates_if_no_local_changes       $*
                        exit
                ;;
                -repo)
                        shift
                        repo_name=$1
                        # if we use this option, we can run from any directory, and the appropriate repo dir will be found (and we will cd there)
                        found=''
                        if [ -d $HOME/git/$repo_name ]; then
                                echo "cd $HOME/git/$repo_name"
                                cd       $HOME/git/$repo_name
                                found=yes
                        else
                                for f in `ls -d $dp/*/$repo_name $dx/*/$repo_name 2> /dev/null`; do
                                        if [ -d "$f" ]; then
                                                echo "cd $f"
                                                cd       $f
                                                found=yes
                                                break
                                        fi
                                done
                        fi
                        if [ -z "$found" ]; then
                                echo "$0: error: could not find repo named $repo_name" 1>&2
                                exit 1
                        fi
                ;;
                -Synchronize_high_traffic_shared_projects_if_no_local_changes)
                        Synchronize_high_traffic_shared_projects
                        exit
                ;;
                -v|-verbose)
                        verbose_mode=-verbose
                ;;
                *)
                        break
                ;;
        esac
        shift
done

comment=`Resolve_comment $*` || echo 1
Checkin || exit 1

exit
bx $dp/bin/git.up -dry_run
ssh -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=0  $ip dp/git_util/git.up -in_dir dp/git/fin_doc_parser
ssh -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=0 $aip git.up -in_dir dp/git/fin_doc_parser
bx $dp/git_util/git.up -Synchronize_high_traffic_shared_projects_if_no_local_changes
exit
bx $dp/git_util/git.up -Pull_latest_updates_if_no_local_changes