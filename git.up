#!/bin/bash

Checkin()
{
        z=`pwd`

        if [ -f git.pre_checkin_test.sh ]; then
                if ! bash git.pre_checkin_test.sh; then
                        if [ -n "$force_mode" ]; then
                                echo "$0: bash git.pre_checkin_test.sh failed, forcing anyway..." 1>&2
                        else
                                echo "$0: bash git.pre_checkin_test.sh failed, exiting..." 1>&2
                                exit 1
                        fi
                fi
        fi
        current_dir=`basename "$z"`
        repo_name=$current_dir
        patt="EARLY"
        patt="$patt.*exit"
        if grep -l \-search $dp/bin/g.sh > /dev/null 2>&1; then
                if g.sh -search $repo_name "$patt"; then
                        echo FAILED early exit indicates debugging
                        exit 1
                fi
        fi
        echo OK no early exit
        if [ -z "$comment" ]; then
                case "$repo_name" in
                        data)
                                comment="shell records"
                        ;;
                        emacs)
                                comment="shortcut update"
                        ;;
                esac
        fi
        case "$repo_name" in
                fin_doc_parser)
                        # frequently aborted test case leads to these files being deleted, and a cascade of false updates. Restore them before update:
                        cp ui/src/public/MCBI_Q2_2018_Report.textract0.json.bak ui/src/public/MCBI_Q2_2018_Report.textract0.json
                        cp ui/src/public/MCBI_Q2_2018_Report.textract.csv.bak ui/src/public/MCBI_Q2_2018_Report.textract.csv
                ;;
        esac

        git.ac $dry_mode $comment

        branch=`git.branch`
        if [ -z "$branch" ]; then
                branch=master
        fi

        echo "git push origin $branch"
        if [ -z "$dry_mode" ]; then
                if orcl.on_vpn; then
                        . git.prep_auth.inc
                        Prep_auth
                fi
                # If someone has beaten us to the punch in getting an update in since our pull, we'll get the following:
                #       error: failed to push some refs to 'https://sproul:...@github.com/sproul/t2.git'
                #       hint: Updates were rejected because the remote contains work that you do
                #       hint: not have locally. This is usually caused by another repository pushing
                #       hint: to the same ref. You may want to first merge the remote changes (e.g.,
                #       hint: 'git pull') before pushing again.
                #       hint: See the 'Note about fast-forwards' in 'git push --help' for details.
                if git push origin $branch > $t 2>&1; then
                        git pull origin $branch
                else
                        if ! grep 'merge the remote changes' $t > /dev/null 2>&1; then
                                if ! grep 'integrate the remote changes' $t > /dev/null 2>&1; then
                                        cat $t
                                        exit 1
                                fi
                        fi
                        echo $0 saw merge problem...
                        echo ===========================================================================
                        cat $t
                        echo ===========================================================================
                        echo will try to rectify by rebasing, which will auto-merge if practical:
                        # before pushing, do this, will auto-merge:
                        echo "git pull --rebase"
                        if [ -z "$dry_mode" ]; then
                                if ! git pull --rebase; then
                                        echo "$0: git pull --rebase failed......................" 1>&2
                                        echo "git status"
                                        git status
                                        echo EOD
                                        echo a way to resolve this:
                                        echo git.repair
                                        exit 1
                                fi
                        fi
                        if ! git push origin $branch; then
                                echo "$0: error: git push origin failed" 1>&2
                                exit 1
                        fi
                fi
                echo "git pull origin $branch"
                if ! git pull origin $branch; then
                        echo "$0: git pull failed, exiting..." 1>&2
                        exit 1
                fi
                . modified_repos.inc
                git_util__modified_repos__Remove_from_list $repo_name
        fi
}

Pull_latest_updates_if_no_local_changes()
{
        proj=$1
        echo $proj=================================
        cd $dp/$proj
        git.d -pull_latest_updates_if_no_local_changes
}



Synchronize_high_traffic_shared_projects()
{
        for proj in bin data emacs git_util; do
                Pull_latest_updates_if_no_local_changes $proj
        done
        case "$HOSTNAME" in
                lt5|x-mac)
                        Pull_latest_updates_if_no_local_changes doc
                        Pull_latest_updates_if_no_local_changes fin_doc_parser
                        Pull_latest_updates_if_no_local_changes monr
                        if orcl.on_vpn; then
                                Pull_latest_updates_if_no_local_changes diagnostic-tool
                        fi
                ;;
        esac

}


Find_comment_in_source_tree()
{
        dotc_list=`find . -name '.c'`
        if [ -n "$dotc_list" ]; then
                comment=`cat $dotc_list`
                rm $dotc_list
                echo $comment
        fi
}

Resolve_comment()
{
        comment_from_parms="$*"
        comment_from_c=`Find_comment_in_source_tree`
        if [ -n "$comment_from_c" ]; then
                if [ -n "$comment_from_parms" ]; then
                        echo "$0: error: did not expect $comment_from_c and also a command line comment -- which should I use?" 1>&2
                        exit 1
                fi
                comment="$comment_from_c"
        else
                comment="$comment_from_parms"
        fi
        echo $comment
}

export PATH=$PATH:`dirname $0`
. git.sync

t=`mktemp`
repo_name=''
dry_mode=''
force_mode=''
new_branch=''
verbose_mode=''
while [ -n "$1" ]; do
        case "$1" in
                a|-all)
                        git.all $dry_mode git.up
                        exit
                ;;
                -in_dir)
                        shift
                        cd "$1"
                ;;
                -dry|-dry_run)
                        dry_mode=-dry
                ;;
                -f|-force)
                        force_mode=-force
                ;;
                -new_branch)
                        new_branch_flag="$1"
                        shift
                        new_branch="$1"
                ;;
                -repo)
                        shift
                        repo_name=$1
                        # if we use this option, we can run from any directory, and the appropriate repo dir will be found (and we will cd there)
                        found=''
                        if [ -d $HOME/git/$repo_name ]; then
                                echo "cd $HOME/git/$repo_name"
                                cd       $HOME/git/$repo_name
                                found=yes
                        else
                                for f in `ls -d $dp/*/$repo_name $dx/*/$repo_name 2> /dev/null`; do
                                        if [ -d "$f" ]; then
                                                echo "cd $f"
                                                cd       $f
                                                found=yes
                                                break
                                        fi
                                done
                        fi
                        if [ -z "$found" ]; then
                                echo "$0: error: could not find repo named $repo_name" 1>&2
                                exit 1
                        fi
                ;;
                -Synchronize_high_traffic_shared_projects_if_no_local_changes)
                        Synchronize_high_traffic_shared_projects
                        exit
                ;;
                -v|-verbose)
                        verbose_mode=-verbose
                ;;
                *)
                        break
                ;;
        esac
        shift
done

comment=`Resolve_comment $*` || echo 1
Checkin

exit
bx $dp/bin/git.up -dry_run
ssh -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=0  $ip dp/git_util/git.up -in_dir dp/git/fin_doc_parser
ssh -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=0 $aip git.up -in_dir dp/git/fin_doc_parser
exit
bx $dp/git_util/git.up -Synchronize_high_traffic_shared_projects_if_no_local_changes)